<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>âš¡Î”Î™Î‘Î£</title>
<!-- /content/inscriptionId -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  body { margin: 0; background: #000; color: #ff9900; font-family: Arial, sans-serif; height: 100vh; display: flex; overflow: hidden; }
  #wrapper { display: flex; flex-direction: column; padding: 10px; width: calc(75% - 3px); min-width: 250px; }
  #editor, #previewFrame { flex: 1;  box-shadow: 0 0 20px 2px #ff9900; background: #250326; color: #FF66C3; outline: none; padding: 8px; width: 100%; height: 100%; }
  /* Sparkles around main */

@keyframes sparkle {
  0% { transform: translate(0, 0); }
  100% { transform: translate(10px, 10px); }
}
  #previewFrame { display: none; background: #111; }
  #fileListContainer { flex: 1; overflow-y: auto;  padding: 6px; background: #1a001a; }
  .file-item.selected { background: #ff9900; color: #000;  }
  button {
  background: linear-gradient(145deg, #d4af37, #8b7500);
  color: #000;
  border: none;
  padding: 6px 12px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.5s ease; /* ğŸŒ¸ smooth fade effect */
  text-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
}
  .view-toggle button.active { filter: brightness(1.2); box-shadow: 0 0 8px 1px #ff9900; }
  #right-panel { display: flex; flex-direction: column; width: 25%; min-width: 150px; border-left: 2px solid #ff9900; padding: 10px; background: #000; }
  #resizer { width: 6px; cursor: ew-resize; background: #ff9900; opacity: 0.5; transition: opacity 0.15s; }
  #resizer:hover { opacity: 1; }

  /* Small spinner beside Virtual Folder */

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

@keyframes jump {
  0% { transform: translateY(0); }
  40% { transform: translateY(-20px); }   /* slow rise */
  55% { transform: translateY(-19px); }   /* linger slightly at the top */
  100% { transform: translateY(0); }      /* fast drop */
}

@keyframes airLift {
  0%   { transform: translateY(0) rotate(0); }
  20%  { transform: translate(-5px, -30px) rotate(-10deg); }  /* caught by wind */
  40%  { transform: translate(10px, -50px) rotate(15deg); }   /* lift higher */
  60%  { transform: translate(-8px, -20px) rotate(-5deg); }   /* swirling */
  100% { transform: translate(0, 0) rotate(0); }              /* land back */
}

button.airborne {
  animation: airLift 0.9s cubic-bezier(0.4, 0.1, 0.2, 1.2);
}


button.jump { animation: jump 0.6s cubic-bezier(0.25, 0.1, 0.3, 5.8); /* ease-in fall */ }
#deleteBtn {
  background: linear-gradient(180deg, #e0f7ff 0%, #b3ecff 80%);
  color: #004466;
  border: none;
  border-radius: 50px;
  padding: 10px 20px;
  font-size: 18px;
  box-shadow:
    0 0 50px rgba(173, 216, 230, 0.8),     /* stronger outer glow */
    0 10px 25px rgba(0, 153, 204, 0.5),   /* soft shadow below (floating depth) */
    inset 0 0 20px rgba(255, 255, 255, 0.8); /* brighter inner light */
  cursor: pointer;
  transition: all 0.3s ease;
}

/* Hover = radiant, heavenly light expansion */
#deleteBtn:hover {
  box-shadow:
    0 0 80px rgba(0, 255, 255, 0.8),
    0 15px 35px rgba(0, 153, 204, 0.6),
    inset 0 0 25px rgba(255, 255, 255, 1);
  background: linear-gradient(180deg, #f8fdff 0%, #d0f6ff 100%);
  transform: scale(1.04);
}

#rotatingCircle {
  width: 42px;
  height: 42px;
  
  /* 3.114588.bitmap */
  background-image: url('https://ordinals.com/content/cca247c9f544b1b8e7679d74c427051f8117687fb223c118ad8095f562e29f0fi144 ');
  background-size: cover;
  background-position: center;
  border-radius: 50%;
  box-shadow: 0 0 10px 2px #ff9900, inset 0 0 5px 1px #ff66c3;
  flex-shrink: 0;
  /* ğŸ§˜ stays still by default */
  animation: none;
}

#rotatingCircle.spinning {
  animation: rotateCircle 2s linear infinite;
}

@keyframes rotateCircle {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}


/* âš¡ Glowing, fading, divine gradient animation */
@keyframes deleteShine {
  0% {
    background: linear-gradient(90deg, #00ccff, #66ffff, #00ccff);
    box-shadow:
      0 0 10px rgba(0, 204, 255, 0.4),
      0 0 20px rgba(102, 255, 255, 0.3);
    transform: scale(1);
    opacity: 0.6;
  }
  25% {
    background: linear-gradient(120deg, #00eaff, #ffffff, #00ccff);
    box-shadow:
      0 0 40px rgba(0, 255, 255, 0.8),
      0 0 80px rgba(255, 255, 255, 0.8);
    transform: scale(1.1);
    opacity: 1;
  }
  50% {
    background: linear-gradient(270deg, #00ccff, #99ffff, #ffffff);
    box-shadow:
      0 0 60px rgba(0, 255, 255, 1),
      0 0 120px rgba(255, 255, 255, 0.9);
    transform: scale(1.2);
    opacity: 1;
  }
  75% {
    background: linear-gradient(150deg, #00eaff, #ffffff, #00ccff);
    box-shadow:
      0 0 40px rgba(0, 255, 255, 0.8),
      0 0 80px rgba(255, 255, 255, 0.7);
    transform: scale(1.1);
    opacity: 0.9;
  }
  100% {
    background: linear-gradient(90deg, #00ccff, #66ffff, #00ccff);
    box-shadow:
      0 0 10px rgba(0, 204, 255, 0.4),
      0 0 20px rgba(102, 255, 255, 0.3);
    transform: scale(1);
    opacity: 0.6;
  }
}

/* Apply the animation */
#deleteBtn.shining {
  animation: deleteShine 2.2s ease-in-out infinite;
}


</style>
</head>
<body>

<!-- Left: Ordinals Loader and Editor -->
<div id="wrapper">
  
  <div style="display:flex; gap:8px; margin-bottom:8px;">
    
  </div>

  <div style="display:flex; gap:8px; margin-bottom:8px;" class="view-toggle">
    <button id="importBtn" style="background:#ff9900; border:none; border-radius:4px; padding:6px 10px;">ğŸ§±</button>
    <button id="prevBtn" style="background:#ff6600; border:none; border-radius:4px; padding:6px 10px;">â—€</button>
    <input id="bitmapInput" placeholder="BITMAP [114588]" style="flex:1; padding:6px; border:1px solid #ff9900; background:#250326; color:#fff; border-radius:4px;">
    <button id="nextBtn" style="background:#ff6600; border:none; border-radius:4px; padding:6px 10px;">â–¶</button>

    <button id="loadBtn" style="background:#ff9900; width:50px; border:none; border-radius:4px; padding:6px 10px;">âš¡</button>

    <input id="filename" placeholder="parcel [0.114588.bitmap.html]" style="flex:1; padding:6px; border:1px solid #ff9900; background:#250326; color:#fff; border-radius:4px;">

    <button id="saveBtn" style="background:#ff6600; border:none; border-radius:4px; padding:6px 10px;" >ğŸ­</button>

    <button id="exportBtn" style="background:#ff9900; border:none; border-radius:4px; padding:6px 10px;"> ğŸŸ§</button>

    <button id="codeBtn" style="background:#333; color:#ff9900; border:none; border-radius:4px; padding:6px 10px;">ğŸŒ±</button>
    <button id="previewBtn" style="background:#333; border:none; border-radius:4px; padding:6px 10px;">ğŸŒ¸</button>
  </div>

  <textarea id="editor" placeholder="Copy|Paste|Write|Read                                                                                                                        HTML/JS/CSS/BITMAP"></textarea>
  <iframe id="previewFrame"></iframe>
</div>

<!-- Resizer -->
<div id="resizer"></div>

<!-- Right: Virtual Folder -->
<div id="right-panel">
<h4 id="folderHeader" style="display:flex; align-items:center; gap:10px;">
  <div id="rotatingCircle"><h3>âš¡Î”</h3></div>
  <input id="searchBox" placeholder="search parcels..." 
       style="margin-bottom:8px; padding:6px; width:100%; border:1px solid #ff9900; background:#250326; color:#fff;">
  <select id="typeFilter" 
        style="margin-bottom:8px; padding:6px; width:100%; border:1px solid #ff9900; background:#250326; color:#fff;">
  <option value="">all types</option>
</select>
  <span id="folderLoading"></span>
</h4>
<script>
// ğŸ–¼ Safely load binary JPEG from localStorage
(async function () {
  const key = "4.114588.bitmap.jpg";
  const iconElement = document.getElementById("folderIcon");
  const rawData = localStorage.getItem(key);

  if (!rawData) {
    console.warn(`âš ï¸ No data found for key: ${key}`);
    return;
  }

  // Check if it's already base64
  if (rawData.startsWith("data:image")) {
    iconElement.src = rawData;
    console.log("ğŸ“ Folder icon loaded (already base64)");
    return;
  }

  // Convert UTF-16 string to binary
  const bytes = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; i++) {
    bytes[i] = rawData.charCodeAt(i) & 0xff;
  }

  // Turn binary into a Blob and then a base64 URL
  const blob = new Blob([bytes], { type: "image/jpeg" });
  const reader = new FileReader();
  reader.onloadend = function () {
    iconElement.src = reader.result; // data:image/jpeg;base64,...
    console.log("ğŸ“ Folder icon restored from binary data");
  };
  reader.readAsDataURL(blob);
})();
</script>




  <div id="fileListContainer"></div>
  <button id="deleteBtn" style="background:#00ccff; border:none; border-radius:4px; padding:6px; margin-top:10px;">ğŸŒ¬ï¸</button>

</div>

<script>
/* ======== HELPERS ======== */
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

/* ======== ORDINALS LOADER ======== */
async function loadOrdinals() {
  if (!bitmapInput.value || bitmapInput.value === "") return alert("Enter BITMAP first");
  const spinner = document.getElementById('folderLoading');
  spinner.style.display = 'inline-block'; // ğŸŒ€ show spinner
  document.getElementById('rotatingCircle').classList.add('spinning');

  try {
    const BITMAP = bitmapInput.value.trim() + ".bitmap";
    const bitmapNumber = BITMAP.replace(".bitmap", "");
    
    let INSCRIPTION_ID = await getBitmapInscriptionId(bitmapNumber);          
    if (!BITMAP || !INSCRIPTION_ID) return alert("Enter BITMAP first");

    console.clear();
    console.log("ğŸ§¹ Clearing localStorage for fresh session...");
    localStorage.clear();
    loadFileList();
updateTypeFilter();

    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("ğŸš€ STARTING ORDINALS LOADER");
    console.log(`ğŸª© BITMAP: ${BITMAP}`);
    console.log(`ğŸ§© INSCRIPTION_ID: ${INSCRIPTION_ID}`);
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    const parcel = "." + BITMAP;
    const txInfoUrl = `https://ordinals.com/r/blockinfo/${bitmapNumber}`;

    console.log(`ğŸ“¡ FETCH â†’ ${txInfoUrl}`);
    const blockInfo = await fetch(txInfoUrl).then(r => r.json()).catch(err => { console.error("âŒ Failed blockinfo:", err); return null; });
    console.log("ğŸ“¦ BLOCKINFO RESPONSE:", blockInfo);
    const transaction_count = blockInfo?.transaction_count || 0;
    console.log(`ğŸ§® TRANSACTION COUNT: ${transaction_count}`);

    const ordinals = new Set();
    let page = 0, more = true, total = 0;

    while (more) {
      const pageUrl = `https://ordinals.com/r/children/${INSCRIPTION_ID}/inscriptions/${page}`;
      console.log(`\nğŸ“œ FETCHING PAGE ${page}: ${pageUrl}`);
      const res = await fetch(pageUrl).then(r => r.json()).catch(err => { console.error("âŒ Page fetch error:", err); return null; });
      if (!res || !res.children) break;

      console.log(`ğŸ“„ PAGE ${page} RESPONSE:`, res);
      console.log(`ğŸ”¹ CHILDREN COUNT: ${res.children.length}`);

      for (const child of res.children) {
        const sat = child.sat;
        if (!sat) continue;

        //get /0 and if it is parcel then get /-1

        const satUrl = `https://ordinals.com/r/sat/${sat}/at/0`;
        console.log(`ğŸ“¡ FETCH key(0) â†’ ${satUrl}`);
        const satData = await fetch(satUrl).then(r => r.json()).catch(() => null);
        if (!satData || !satData.id) continue;

        const id = satData.id;
        const contentUrl = `https://ordinals.com/content/${id}`;
        console.log(`ğŸ“¡ FETCH CONTENT key(0)â†’ ${contentUrl}`);
        const response = await fetch(contentUrl).catch(() => null);
        if (!response) continue;

      
        let content = await response.text();


        console.log(`content: ${content}`);
        console.log(`parcel: ${parcel}`);
        console.log(`isAPrcel: ${ordinals}`);
        console.log(`transaction_count: ${transaction_count}`);
        const number = isParcel(content, parcel, ordinals, transaction_count);

        if (number !== null) {
          console.log(`âœ… VALID PARCEL FOUND #${number}`);
          let key = content





          //find last reinscription to find content
          //
          const satUrl = `https://ordinals.com/r/sat/${sat}/at/-1`;
          console.log(`ğŸ“¡ FETCH value(-1) â†’ ${satUrl}`);
          const satData = await fetch(satUrl).then(r => r.json()).catch(() => null);
          if (!satData || !satData.id) continue;

          const id = satData.id;
          const contentUrl = `https://ordinals.com/content/${id}`;
          console.log(`ğŸ“¡ FETCH CONTENT value(-1) â†’ ${contentUrl}`);
          const response = await fetch(contentUrl).catch(() => null);
          if (!response) continue;

          //find extention for the key from the lastreinscriptionType
          //
          const mime = response.headers.get("content-type") || "text/plain";
          let extension = "";
          if (mime.includes("html")) extension = ".html";
          else if (mime.includes("javascript")) extension = ".js";
          else if (mime.includes("css")) extension = ".css";
          else if (mime.includes("json")) extension = ".json";
          else if (mime.includes("svg")) extension = ".svg";
          else if (mime.includes("image/png")) extension = ".png";
          else if (mime.includes("image/jpeg")) extension = ".jpg";
          else if (mime.includes("image/gif")) extension = ".gif";
          else if (mime.includes("text/plain")) extension = ".txt";
          else if (mime.includes("text/markdown")) extension = ".md";
          else if (mime.includes("application/pdf")) extension = ".pdf";
          else extension = "";

          // Read as text or base64
          let content2;
          if (mime.startsWith("image/") || mime === "application/pdf") {
            const blob = await response.blob();
            content2 = await blobToBase64(blob);
          } else {
            content2 = await response.text();
          }






          // let fileName = content.trim().split('\n')[0].replace(/[<>:"/\\|?*\x00-\x1F]/g, "_").substring(0, 80);
          // if (!fileName) fileName = id;

          // if (!fileName.endsWith(extension)) fileName += extension;
          let fileName = key+extension;
          localStorage.setItem(fileName, content2);
          console.log(`ğŸ’¾ Saved file â†’ ${fileName} (${mime})`);
          if (!fileName || fileName.length === 0) return alert("Load BITMAP ");
         
          total++;
          loadFileList();
updateTypeFilter();
        }
      }

      more = res.more;
      page++;
    }

    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log(`ğŸ COMPLETED | ğŸ’ Found: ${ordinals.size} | ğŸ’¾ Saved: ${total}`);
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  } finally {
    spinner.style.display = 'none'; // âœ… hide spinner when done
    document.getElementById('rotatingCircle').classList.remove('spinning');
  }
}

function isParcel(content, parcel, ordinals, txCount) {
  content = content.trim();
  if (!content.endsWith(parcel)) return null;
  const base = content.replace(parcel, "").trim();
  if (!/^\d+$/.test(base)) return null;
  const num = parseInt(base);
  console.log(`num: â†’ ${num} `);
  if (!ordinals.has(num) && num <= txCount) {
    ordinals.add(num);
    return num;
  }
  return null;
}

/* ======== VIRTUAL FILE SYSTEM ======== */
function saveFile() {

  const name = filename.value.trim();
  if (!name || name === 0 && bitmapInput.value) return alert("Load BITMAP ");
  localStorage.setItem(name, editor.value);
  console.log(`ğŸ’¾ Saved file â†’ ${name}`);
  loadFileList();
updateTypeFilter();
}
function updateTypeFilter() {
  const select = document.getElementById("typeFilter");
  const keys = Object.keys(localStorage);

  const extensions = new Set();

  keys.forEach(k => {
    const match = k.match(/\.[a-zA-Z0-9]+$/);
    if (match) extensions.add(match[0].toLowerCase());
  });

  // Clear old options (but keep "all types")
  select.innerHTML = '<option value="">all types</option>';

  [...extensions].sort().forEach(ext => {
    const op = document.createElement("option");
    op.value = ext;
    op.textContent = ext;
    select.appendChild(op);
  });
}


function loadFileList() {
  const box = document.getElementById('fileListContainer');
  box.innerHTML = '';
  const keys = Object.keys(localStorage);

  const search = document.getElementById("searchBox")?.value.trim().toLowerCase() || "";

  if (keys.length === 0) {
    box.innerHTML = `
    <p style="color:#b8a95d; font-style:italic; white-space:pre-line;">
Ahâ€¦ listen, wanderer of the chain. ğŸ‘€

The parcels are not always seen â€”
they whisper beneath the pixels,
where the blocks breathe and the sats remember.
You wonâ€™t find them by sight alone,
for they hide between inscriptions and intent,
in the spaces where code turns to creation.

Each bitmap is a mountain of Olympus,
and each parcel â€” a spark of divine will,
awaiting the mortal who dares to read between the bytes.
Some call them files, some call them dreams,
but the wise know: they are fragments of thought,
scattered across the blockchain sky.

So keep looking.
Not for what you can see â€”
but for what responds when you touch it with purpose.
Perhaps the parcel isnâ€™t lost.
Perhaps you were meant to find it
only when you understand
that you, too, are a parcel of the gods. âš¡
    </p>`;
    return;
  }



let filtered = keys;

// ğŸ” Text search filter
if (search !== "") {
  filtered = filtered.filter(k => {
    const value = localStorage.getItem(k) || "";
    return value.toLowerCase().includes(search);
  });
}

// ğŸ—‚ Type filter
const selectedType = document.getElementById("typeFilter").value;
if (selectedType) {
  filtered = filtered.filter(k => k.toLowerCase().endsWith(selectedType));
}

// Sort (numeric when no search, alphabetic when searching)
if (search === "") {
  filtered.sort((a, b) => {
    const numA = parseInt(a.split(".")[0], 10);
    const numB = parseInt(b.split(".")[0], 10);

    if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
    if (!isNaN(numA)) return -1;
    if (!isNaN(numB)) return 1;
    return a.localeCompare(b);
  });
} else {
  filtered.sort((a, b) => a.localeCompare(b));
}


  // Show results
  filtered.forEach(k => {
    const div = document.createElement('div');
    div.textContent = k;
    div.className = 'file-item';
    div.style.cursor = 'pointer';
    div.style.padding = '4px';

div.addEventListener('click', () => {
  document.querySelectorAll('.file-item').forEach(el => el.classList.remove('selected'));
  div.classList.add('selected');

  let content = localStorage.getItem(k);
  let search = document.getElementById("searchBox").value.trim();

  if (search !== "") {
    content = highlightSearchInEditor(content, search);
  }

  // Replace highlight markers visually (without touching the real data)
  editor.value = content.replace(/<<HIGHLIGHT:(.*?)>>/g, (a, b) => b);

  // Apply yellow highlight in textarea
  setTimeout(() => {
    const html = editor.value.replace(
      new RegExp(search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi"),
      match => `<mark style="background:yellow; color:black;">${match}</mark>`
    );
    previewFrame.contentDocument.body.innerHTML = `<pre>${html}</pre>`;
  }, 50);

  filename.value = k;
});


    box.appendChild(div);
  });
}


/* ======== IMPORT / EXPORT ======== */
async function importFolder() {
  const input = document.createElement('input');
  input.type = 'file';
  input.webkitdirectory = true;
  input.multiple = true;
  input.onchange = async e => {
    const files = Array.from(e.target.files);
    if (files.length === 0) return;

    // ğŸ§¹ Clear localStorage before importing
    console.clear();
    console.log("ğŸ§¹ Clearing localStorage before folder import...");
    localStorage.clear();
    loadFileList();
updateTypeFilter();

    for (const file of files) {
      let content;
if (file.type.startsWith("image/") || file.type === "application/pdf") {
  const blob = file;
  content = await blobToBase64(blob); // store as base64
} else {
  content = await file.text();
}
localStorage.setItem(file.name, content);

      console.log(`ğŸ“¥ Imported: ${file.name}`);
    }

    loadFileList();
updateTypeFilter();
    alert(`ğŸ§± Loaded ${files.length} parcels`);

    // ğŸŒ¸ Automatically set bitmapInput name
    const firstFile = files[0];
    if (firstFile && firstFile.webkitRelativePath) {
      const folderPath = firstFile.webkitRelativePath.split('/')[0];
      const cleanName = folderPath.replace(/\.bitmap$/i, '');
      document.getElementById("bitmapInput").value = cleanName;
      console.log(`ğŸª¶ Set bitmapInput â†’ "${cleanName}"`);
    }
  };
  input.click();
}



async function exportFolder() {
  const zip = new JSZip();
  const keys = Object.keys(localStorage);
  if (keys.length === 0) return alert('No parcels to discharge.');

  for (const k of keys) {
    let content = localStorage.getItem(k);

    // ğŸ–¼ Detect base64-encoded image or PDF
    if (content.startsWith("data:image") || content.startsWith("data:application/pdf")) {
      // Split header and actual data
      const base64Data = content.split(",")[1];
      const binaryData = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));
      zip.file(k, binaryData, { binary: true });
    } else {
      // Regular text file
      zip.file(k, content);
    }
  }

  // Generate ZIP blob
  const blob = await zip.generateAsync({ type: "blob" });
  const url = URL.createObjectURL(blob);

  // ğŸŒ¸ Use the bitmapInput value as the file name
  let name = document.getElementById("bitmapInput").value.trim() || "bitmap";
  name = name.replace(/[^a-zA-Z0-9._-]/g, "_");

  const a = document.createElement('a');
  a.href = url;
  a.download = `${name}.bitmap.zip`;
  a.click();
  URL.revokeObjectURL(url);

  console.log(`ğŸ’¾ Exported ZIP â†’ ${name}.bitmap.zip`);
}



/* ======== PREVIEW ======== */
function resolveLocalImports(html) {
  html = html.replace(/<script\s+src=["']([^"']+)["']><\/script>/g, (_, f) => {
    const c = localStorage.getItem(f);
    return c ? "<script>\n" + c + "\n<\/script>" : `<script src="${f}"><\/script>`;
  });
  html = html.replace(/<link\s+[^>]*href=["']([^"']+)["'][^>]*>/g, (_, f) => {
    const c = localStorage.getItem(f);
    return c ? "<style>\n" + c + "\n</style>" : `<link href="${f}" rel="stylesheet">`;
  });

  // ğŸ’– Add a soft pink background to the preview
  const pinkStyle = `
    <style>
      body {
        background: linear-gradient(145deg, #FF66C3, #ff3e96);
        color: #FF66C3;
      }
    </style>
  `;
  return pinkStyle + html;
}

function preview() {
  const doc = previewFrame.contentDocument;
  const val = editor.value.trim();

  // ğŸ“¸ If it's a base64 image or PDF, show it directly
  if (val.startsWith("data:image") || val.startsWith("data:application/pdf")) {
    doc.open();
    doc.write(`<body style="margin:0; background:#000; display:flex; align-items:center; justify-content:center;">
                 <img src="${val}" style="max-width:100%; max-height:100%;">
               </body>`);
    doc.close();
    return;
  }

  // Otherwise, normal HTML preview
  const resolved = resolveLocalImports(val);
  editor.classList.add('sparkle');
  doc.open();
  doc.write(resolved);
  doc.close();
}


function showCodeView() {
  editor.style.display = 'block';
  previewFrame.style.display = 'none';
  codeBtn.classList.add('active');
  setTimeout(() => codeBtn.classList.remove('active'), 200);
}

function showPreviewView() {
  preview();
  editor.style.display = 'none';
  previewFrame.style.display = 'block';
  previewBtn.classList.add('active');
  setTimeout(() => previewBtn.classList.remove('active'), 1000);
}

/* ======== RESIZER ======== */
const resizer = document.getElementById('resizer');
const left = document.getElementById('wrapper');
let isDragging = false, startX = 0, startWidth = 0;
resizer.addEventListener('mousedown', e => {
  isDragging = true;
  startX = e.clientX;
  startWidth = left.offsetWidth;
  document.body.style.cursor = 'ew-resize';
  e.preventDefault();
});
document.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - startX;
  left.style.width = Math.max(250, startWidth + dx) + 'px';
});
document.addEventListener('mouseup', () => {
  isDragging = false;
  document.body.style.cursor = 'default';
});

/* ======== BITMAP NAVIGATION ======== */
function changeBitmap(delta) {
  let input = document.getElementById('bitmapInput');
  let val = input.value.trim();
  let num = parseInt(val.replace(/\.bitmap$/i, ''));
  if (isNaN(num)) return alert('Invalid BITMAP [number]');
  num += delta;
  if (num < 0) num = 0;
  input.value = num;
  console.log(`ğŸ”„ Switching to BITMAP: ${num}.bitmap`);
  loadOrdinals();
}

prevBtn.onclick = () => changeBitmap(-1);
nextBtn.onclick = () => changeBitmap(1);

saveBtn.onclick = () => {
  saveBtn.classList.add('airborne');
  setTimeout(() => saveBtn.classList.remove('airborne'), 900);

  saveFile();
};
deleteBtn.onclick = () => {
  const sel = document.querySelector('.file-item.selected');
  if (!sel) return alert('Select parcel first');
  const name = sel.textContent;

  if (confirm("ğŸ’€" + name + "ğŸ’€")) {
    // ğŸŒŸ Start glowing animation
    deleteBtn.classList.add('shining');

    // Remove file
    localStorage.removeItem(name);
    loadFileList();
updateTypeFilter();
    editor.value = '';

    // ğŸ’« Stop animation after 2 seconds
    setTimeout(() => {
      deleteBtn.classList.remove('shining');
    }, 2000);
  }
};

importBtn.onclick = importFolder;
exportBtn.onclick = exportFolder;
codeBtn.onclick = showCodeView;
previewBtn.onclick = () => {
  // 1ï¸âƒ£ Check if any file is selected
  let selected = document.querySelector('.file-item.selected');
  
  // 2ï¸âƒ£ If no file selected, select the first one
  if (!selected) {
    const first = document.querySelector('.file-item');
    if (first) {
      first.classList.add('selected');
      const key = first.textContent;
      const value = localStorage.getItem(key);
      editor.value = value;
      filename.value = key;
      console.log(`ğŸ“‚ Auto-selected first file â†’ ${key}`);
    } else {
      alert("âš ï¸ No files in the virtual folder!");
      return; // stop if no files at all
    }
  }

  // 3ï¸âƒ£ Continue with normal preview logic
  showPreviewView();
};
loadBtn.onclick = () => {
  if (bitmapInput.value) {
    // Random direction and intensity
    const randomX = (Math.random() - 0.5) * 100; // left or right up to Â±50px
    const randomY = (Math.random() - 0.5) * 100; // up or down up to Â±50px
    const randomRotate = (Math.random() - 0.5) * 90; // rotate up to Â±45Â°

    // Apply an abrupt, dramatic jump
    loadBtn.style.transition = "transform 0.15s cubic-bezier(0.1, 0.8, 0.1, 1.2)";
    loadBtn.style.transform = `translate(${randomX}px, ${randomY}px) rotate(${randomRotate}deg)`;

    // Snap back to original position
    setTimeout(() => {
      loadBtn.style.transition = "transform 0.2s ease-in";
      loadBtn.style.transform = "translate(0, 0) rotate(0)";
    }, 150);
  }
  // Call your existing function
  loadOrdinals();
};

document.getElementById("typeFilter").addEventListener("change", loadFileList);
document.getElementById("searchBox").addEventListener("input", loadFileList);


function highlightSearchInEditor(content, search) {
  if (!search) return content;

  // Escape regex characters
  const safe = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

  const regex = new RegExp(safe, "gi");

  return content.replace(regex, match => `<<HIGHLIGHT:${match}>>`);
}


loadFileList();
updateTypeFilter();
</script>

<script>
(function (global) {
  const BASE_URL = "https://ordinals.com";
  const pages = Array(8).fill(null);
  const allPages = [
    `${BASE_URL}/content/01bba6c58af39d7f199aa2bceeaaba1ba91b23d2663bc4ef079a4b5e442dbf74i0`,
    `${BASE_URL}/content/bb01dfa977a5cd0ee6e900f1d1f896b5ec4b1e3c7b18f09c952f25af6591809fi0`,
    `${BASE_URL}/content/bb02e94f3062facf6aa2e47eeed348d017fd31c97614170dddb58fc59da304efi0`,
    `${BASE_URL}/content/bb037ec98e6700e8415f95d1f5ca1fe1ba23a3f0c5cb7284d877e9ac418d0d32i0`,
    `${BASE_URL}/content/bb9438f4345f223c6f4f92adf6db12a82c45d1724019ecd7b6af4fcc3f5786cei0`,
    `${BASE_URL}/content/bb0542d4606a9e7eb4f31051e91f7696040db06ca1383dff98505618c34d7df7i0`,
    `${BASE_URL}/content/bb06a4dffba42b6b513ddee452b40a67688562be4a1345127e4d57269e6b2ab6i0`,
    `${BASE_URL}/content/bb076934c1c22007b315dd1dc0f8c4a2f9d52f348320cfbadc7c0bd99eaa5e18i0`,
    `${BASE_URL}/content/bb084ed0d70c336861e794c5a2d41a19df8b5531b51ffe71a868695c20cafed2i0`
  ];

  async function fillPage(page) {
    console.log(`Fetching page ${page}`);
    let data = await fetch(allPages[page]).then((r) => r.text());
    if (page === 2 || page === 3) {
      data = "[" + data + "]";
      data = JSON.parse(data);
      data = [data.slice(0, 99999), data.slice(100000, 199999)];
    } else {
      try { data = JSON.parse(data.replaceAll("\\n  ", "")); } catch (e) {}
      try { data = JSON.parse(data.replaceAll("  ", "")); } catch (e) {}
    }
    const fullSats = [];
    data[0].forEach((sat, i) => {
      fullSats.push(i === 0 ? parseInt(sat) : parseInt(fullSats[i - 1]) + parseInt(sat));
    });
    let filledArray = Array(100000).fill(0);
    data[1].forEach((index, i) => { filledArray[index] = fullSats[i]; });
    pages[page] = filledArray;
  }

  async function getBitmapSat(bitmapNumber) {
    const page = Math.floor(bitmapNumber / 100000);
    if (!pages[page]) await fillPage(page);
    return pages[page][bitmapNumber % 100000];
  }

  async function getBitmapInscriptionId(bitmapNumber) {
    const sat = await getBitmapSat(bitmapNumber);
    const id = await fetch(`${BASE_URL}/r/sat/${sat}/at/0`).then((r) => r.json());
    return id.id;
  }

  global.getBitmapInscriptionId = getBitmapInscriptionId;
})(window);
</script>

<script>
// Display footer text dynamically at the bottom of the screen
const footerNote = document.createElement("div");
footerNote.textContent = "change only the parts you want to change find the parcel with the code and change it be part of the permissionless nft or just be the nft or create with the nft or just fix the code or just break the code whatever you choose it is you you create it congratulation you break it or just bring it to life with the power of ZEUS maybe it is time to find the mother of gods the god that can find you anything you are looking i hope when you will read this you will already part of it otherwise you just became you are experiencing the power of ZEUS have fun and enjoy the -Bitmap Olumpus- this is a text that will be sold for 0.114588 Bitcoin ";
footerNote.style.position = "fixed";
footerNote.style.bottom = "40px";
footerNote.style.left = "47%";
footerNote.style.transform = "translateX(-50%)";
footerNote.style.color = "#250326";
footerNote.style.fontSize = "12px";
footerNote.style.fontFamily = "monospace";
footerNote.style.opacity = "0.8";
footerNote.style.pointerEvents = "none"; // so it doesn't block clicks
document.body.appendChild(footerNote);
</script>

</body>
</html>
